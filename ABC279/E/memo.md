# 回答中のメモ

累積和みたいなことをすれば良いのかも

k=pまでの操作を行った後に、元のインデックスがどこに移動するかを保持するSと
逆順にk=pまでの操作を行った後に、元のインデックスがどこに移動するかを保持するS_revを作成する

```
1 2 3 2
S = [
    [0, 1, 2, 3, 4], # 操作なし
    [1, 0, 2, 3, 4], # k = 1
    [1, 2, 0, 3, 4], # k = 2
    [1, 2, 3, 0, 4], # k = 3
    [1, 3, 2, 0, 4]  # k = 4
]

S_rev = [
    [0, 1, 2, 3, 4], # 操作なし
    [0, 2, 1, 3, 4], # k = 4
    [0, 2, 3, 1, 4], # k = 3
    [0, 3, 2, 1, 4], # k = 2
    [3, 1, 2, 1, 4]  # k = 1
]
```

```
B = 1 2 3 4 5

B = [B[i] for i in range(S[j-1])]
B = [B[i] for i, v in enumerate(S[j+1])]
```
