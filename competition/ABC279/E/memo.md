# 回答中のメモ1

累積和みたいなことをすれば良いのかも

k=pまでの操作を行った後に、元のインデックスがどこに移動するかを保持するSと
逆順にk=pまでの操作を行った後に、元のインデックスがどこに移動するかを保持するS_revを作成する

```
1 2 3 2
S = [
    [0, 1, 2, 3, 4], # 操作なし
    [1, 0, 2, 3, 4], # k = 1
    [1, 2, 0, 3, 4], # k = 2
    [1, 2, 3, 0, 4], # k = 3
    [1, 3, 2, 0, 4]  # k = 4
]

S_rev = [
    [0, 1, 2, 3, 4], # 操作なし
    [0, 2, 1, 3, 4], # k = 4
    [0, 2, 3, 1, 4], # k = 3
    [0, 3, 2, 1, 4], # k = 2
    [3, 1, 2, 1, 4]  # k = 1
]
```

```
B = 1 2 3 4 5

B = [B[i] for i in range(S[j-1])]
B = [B[i] for i, v in enumerate(S[j+1])]
```

# 回答中のメモ２
上記の方法だと、SとS_revが配列を保持することになり、累積の計算の際に配列のコピーに計算量がO（N）かかってしまいTLEになった。

なので、保持するものを減らせないかを考える。

Aの全ての値を用いて、入れ替えを行なった後のB_allを求める。

この時、Aiの入れ替えを行わなかったB_iを考える。
B_iは、Aiの入れ替えを行わなかったため、B_allでは入れ替えを行なった数字（仮にPとQとする）を入れ替えたものになっている

B_all = 1 2 P 4 Q
B_i   = 1 2 Q 4 P

もしこの入れ替えた２つの数字に1が含まれていないなら、B_allとB_iの1の位置は同じ
もしこの入れ替えた２つの数字に1が含まれているなら、　Aiの入れ替えで１と位置を交換した数字をRとすると、B_allのRとB_iの１の位置が同じになる。


そのため、各でAiで1と入れ替わった数字が何であるかだけを記録すれば良い
