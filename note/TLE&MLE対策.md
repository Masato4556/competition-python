
# 型の変換をなるべく少なくする
型変換をすることで、意図せず計算量が増えることがあるので要注意。
（例）、str->intは、桁数が大きくなるほど処理が重くなるみたい。

そのため、なるべく型変換の頻度を少なくする。

# 配列のサイズをなるべく小さくする
- 動的計画法などで結果を格納するdp配列のサイズを最低限のサイズにすることで解けた問題があった。
  - https://atcoder.jp/contests/dp/submissions/41248818

# listよりsetを用いる
setの方がメモリ使用量が少ない

# 再起処理を用いない
再起処理を用いないように書き換えることで、TLEを回避できる問題があった。

# 配列に同じ値を大量に追加する操作がある場合
`A.extend([1] * 100)`のように、extendで追加する方が、1つずつappendするより早い

また、ランレングス圧縮して(数値、個数)というような形式で管理することを検討しても良いかも
そうすることで、計算量がぐっと減る。
ランレングス圧縮については、utils/run_length_encoding.pyを参考にする

AC
https://atcoder.jp/contests/dp/submissions/41259995
TLE
https://atcoder.jp/contests/dp/submissions/41259803

# 意外と計算量が大きい処理に注意

## 配列の反転
- `A[::-1]` より、`A.reverse()`を用いた方が良い
  - スライスでの反転を用いた場合、処理が遅い。

## 配列での値の検索
配列での値の検索は、計算量がO(N)であることが多い
setなどで代替できるかを検討すべき

- list.index(v): O(N)
- x in list: O(N)


# キューを用いるとき
dequeを用いるのが良いらしい。


# 使用言語について
処理によって、どの言語（Python/PyPy3/Cython）が早いかわからない
なぜか、Pythonが一番早くなるケースもあった。

どのようなケースで、どの言語を使うべきなのかはまだわからないが、
TLEやMLEで落ちて、どうしようもなくなった時は、別の言語に変えるのもありかも
※　Cythonは、そのままでは動かないこともある

## PyPyの特徴
メリット
・動作が速い

デメリット
・メモリの使用量が多い
・再帰の動作が遅い

注意点
・bool型の動作が遅い。　ブール値ではなく0/1で扱う方がよい

## Cythonの特徴
メリット
・最適化を突き詰めれば動作がとても速い
・再帰の動作が速い
・省メモリ

デメリット
・最適化をしないと速度は普通


# リンク
https://qiita.com/Ll_e_ki/items/e64cf06705bd5d16a6e9